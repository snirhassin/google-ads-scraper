<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Google Ads Transparency Scraper</title>
    <link rel="stylesheet" href="styles.css">
</head>
<body>
    <div class="container">
        <header>
            <h1>Google Ads Transparency Scraper</h1>
            <p>Extract ad data from Google Ads Transparency pages using Apify + Claude Vision OCR</p>
        </header>

        <main>
            <section class="input-section">
                <div class="url-input-group">
                    <label for="transparency-url">Enter Google Ads Transparency URL:</label>
                    <input
                        type="url"
                        id="transparency-url"
                        placeholder="https://adstransparency.google.com/?region=anywhere&domain=example.com"
                        required
                    >
                    <div class="scraper-options">
                        <label for="scraper-select">Scraper:</label>
                        <select id="scraper-select">
                            <option value="apify" selected>Apify (default)</option>
                            <option value="serpapi">SerpAPI (faster for large advertisers)</option>
                        </select>
                        <label for="max-results">Max Ads:</label>
                        <select id="max-results" style="padding: 8px 12px; border: 2px solid #e0e0e0; border-radius: 6px; font-size: 14px; background: white; cursor: pointer;">
                            <option value="100" selected>100 ads</option>
                            <option value="1000">1,000 ads</option>
                            <option value="10000">All ads</option>
                        </select>
                    </div>
                    <div class="button-group">
                        <button id="start-btn" class="btn btn-primary">Start Scraping</button>
                        <button id="stop-scrape-btn" class="btn btn-danger" style="display: none;">Stop & Save Results</button>
                        <button id="load-saved-btn" class="btn btn-secondary">Load Saved</button>
                    </div>
                </div>
                <div class="example-urls">
                    <p><strong>Example URLs:</strong></p>
                    <code>https://adstransparency.google.com/?region=anywhere&domain=amazon.com</code>
                    <code>https://adstransparency.google.com/advertiser/AR18082589962938613761?region=US</code>
                </div>
            </section>

            <!-- Saved Sessions Modal -->
            <section class="saved-sessions-section" id="saved-sessions-section" style="display: none;">
                <div class="saved-sessions-header">
                    <h3>Saved Sessions</h3>
                    <button id="close-saved-btn" class="btn btn-small btn-secondary">Close</button>
                </div>
                <div class="saved-sessions-list" id="saved-sessions-list">
                    <p class="no-saved">No saved sessions found</p>
                </div>
            </section>

            <section class="progress-section" id="progress-section" style="display: none;">
                <div class="progress-info">
                    <h3>Scraping in Progress</h3>
                    <div class="progress-bar">
                        <div class="progress-fill" id="progress-fill"></div>
                    </div>
                    <div class="progress-details">
                        <div class="progress-stats">
                            <span id="current-status">Initializing...</span>
                        </div>
                        <div class="progress-numbers">
                            <span id="ads-count">0 ads</span>
                            <span class="separator">•</span>
                            <span id="elapsed-time">0:00</span>
                            <span class="separator">•</span>
                            <span id="eta">ETA: calculating...</span>
                        </div>
                    </div>
                    <div class="progress-phases" id="progress-phases">
                        <div class="phase active" id="phase-fetch">
                            <span class="phase-icon">●</span>
                            <span class="phase-text">Fetching ads</span>
                        </div>
                        <div class="phase" id="phase-ocr">
                            <span class="phase-icon">○</span>
                            <span class="phase-text">Extracting ad text (AI)</span>
                        </div>
                    </div>
                </div>
            </section>

            <section class="results-section" id="results-section" style="display: none;">
                <div class="results-header">
                    <h3>Scraped Ads Data (<span id="total-count">0</span> ads) <span id="vision-stats" class="vision-stats"></span></h3>
                    <div class="results-actions">
                        <button id="save-results-btn" class="btn btn-warning">Save Results</button>
                        <button id="export-excel-btn" class="btn btn-success">Export Excel</button>
                        <button id="export-json-btn" class="btn btn-primary">Export JSON</button>
                        <button id="clear-results-btn" class="btn btn-secondary">Clear</button>
                    </div>
                </div>
                <div class="ocr-controls" id="ocr-controls" style="display: none;">
                    <span class="ocr-label">AI Text Extraction:</span>
                    <span id="ocr-progress-display"><span id="ocr-progress">0/0</span> processed</span>
                    <span id="ocr-failed-count" class="ocr-failed-count" style="display: none;"></span>
                    <button id="rerun-failed-btn" class="btn btn-danger btn-small" style="display: none;">Re-run Failed</button>
                    <button id="rerun-selected-btn" class="btn btn-primary btn-small" style="display: none;">Re-run Selected (0)</button>
                    <button id="stop-ocr-btn" class="btn btn-secondary btn-small" style="display: none;">Stop OCR</button>
                    <span id="ocr-status"></span>
                </div>
                <div class="results-meta" id="results-meta"></div>
                <div class="results-table-container">
                    <table id="results-table">
                        <thead>
                            <tr>
                                <th class="checkbox-col"><input type="checkbox" id="select-all-ads" title="Select all"></th>
                                <th>Image</th>
                                <th>Advertiser</th>
                                <th>Title / Headline</th>
                                <th>Description / Snippet</th>
                                <th>Visible Link</th>
                                <th>Format</th>
                                <th>Date Range</th>
                                <th>OCR</th>
                                <th>Details</th>
                            </tr>
                        </thead>
                        <tbody id="results-tbody">
                        </tbody>
                    </table>
                </div>
            </section>

            <section class="error-section" id="error-section" style="display: none;">
                <div class="error-message">
                    <h3>Error</h3>
                    <p id="error-text"></p>
                    <button id="retry-btn" class="btn btn-primary">Try Again</button>
                </div>
            </section>
        </main>

        <footer>
            <p>Powered by <a href="https://apify.com" target="_blank">Apify</a> + <a href="https://anthropic.com" target="_blank">Claude Vision</a></p>
        </footer>
    </div>

    <!-- Save Dialog -->
    <div class="modal" id="save-modal" style="display: none;">
        <div class="modal-content">
            <h3>Save Results</h3>
            <div class="form-group">
                <label for="save-name">Session Name:</label>
                <input type="text" id="save-name" placeholder="e.g., Amazon Ads Analysis">
            </div>
            <div class="modal-actions">
                <button id="confirm-save-btn" class="btn btn-primary">Save</button>
                <button id="cancel-save-btn" class="btn btn-secondary">Cancel</button>
            </div>
        </div>
    </div>

    <script src="https://cdn.sheetjs.com/xlsx-latest/package/dist/xlsx.full.min.js"></script>
    <script>
        let scrapedAds = [];
        let currentMeta = {};
        let scrapeAborted = false;

        const STORAGE_KEY = 'google-ads-scraper-sessions';
        const DB_NAME = 'GoogleAdsScraperDB';
        const DB_VERSION = 1;
        const STORE_NAME = 'sessions';
        let db = null;

        // Initialize IndexedDB
        async function initDB() {
            return new Promise((resolve, reject) => {
                const request = indexedDB.open(DB_NAME, DB_VERSION);

                request.onerror = () => reject(request.error);
                request.onsuccess = () => {
                    db = request.result;
                    resolve(db);
                };

                request.onupgradeneeded = (event) => {
                    const database = event.target.result;
                    if (!database.objectStoreNames.contains(STORE_NAME)) {
                        const store = database.createObjectStore(STORE_NAME, { keyPath: 'id' });
                        store.createIndex('savedAt', 'savedAt', { unique: false });
                    }
                };
            });
        }

        // Migrate from localStorage to IndexedDB
        async function migrateFromLocalStorage() {
            try {
                const oldData = localStorage.getItem(STORAGE_KEY);
                if (oldData) {
                    const sessions = JSON.parse(oldData);
                    for (const session of sessions) {
                        await saveSessionToDB(session);
                    }
                    localStorage.removeItem(STORAGE_KEY);
                    console.log(`Migrated ${sessions.length} sessions to IndexedDB`);
                }
            } catch (e) {
                console.error('Migration error:', e);
            }
        }

        // Save session to IndexedDB
        async function saveSessionToDB(session) {
            return new Promise((resolve, reject) => {
                const transaction = db.transaction([STORE_NAME], 'readwrite');
                const store = transaction.objectStore(STORE_NAME);
                const request = store.put(session);
                request.onsuccess = () => resolve(request.result);
                request.onerror = () => reject(request.error);
            });
        }

        // Get all sessions from IndexedDB
        async function getAllSessionsFromDB() {
            return new Promise((resolve, reject) => {
                const transaction = db.transaction([STORE_NAME], 'readonly');
                const store = transaction.objectStore(STORE_NAME);
                const request = store.getAll();
                request.onsuccess = () => {
                    const sessions = request.result.sort((a, b) =>
                        new Date(b.savedAt) - new Date(a.savedAt)
                    );
                    resolve(sessions);
                };
                request.onerror = () => reject(request.error);
            });
        }

        // Get single session from IndexedDB
        async function getSessionFromDB(id) {
            return new Promise((resolve, reject) => {
                const transaction = db.transaction([STORE_NAME], 'readonly');
                const store = transaction.objectStore(STORE_NAME);
                const request = store.get(id);
                request.onsuccess = () => resolve(request.result);
                request.onerror = () => reject(request.error);
            });
        }

        // Delete session from IndexedDB
        async function deleteSessionFromDB(id) {
            return new Promise((resolve, reject) => {
                const transaction = db.transaction([STORE_NAME], 'readwrite');
                const store = transaction.objectStore(STORE_NAME);
                const request = store.delete(id);
                request.onsuccess = () => resolve();
                request.onerror = () => reject(request.error);
            });
        }

        // Initialize DB on page load
        initDB().then(() => {
            migrateFromLocalStorage();
        }).catch(err => {
            console.error('Failed to init IndexedDB:', err);
        });

        const urlInput = document.getElementById('transparency-url');
        const startBtn = document.getElementById('start-btn');
        const progressSection = document.getElementById('progress-section');
        const resultsSection = document.getElementById('results-section');
        const errorSection = document.getElementById('error-section');
        const errorText = document.getElementById('error-text');
        const resultsTableBody = document.getElementById('results-tbody');
        const totalCount = document.getElementById('total-count');
        const statusSpan = document.getElementById('current-status');
        const visionStats = document.getElementById('vision-stats');
        const resultsMeta = document.getElementById('results-meta');
        const savedSessionsSection = document.getElementById('saved-sessions-section');
        const savedSessionsList = document.getElementById('saved-sessions-list');
        const saveModal = document.getElementById('save-modal');
        const saveNameInput = document.getElementById('save-name');

        // Event Listeners
        startBtn.addEventListener('click', startScraping);
        document.getElementById('export-excel-btn').addEventListener('click', exportToExcel);
        document.getElementById('export-json-btn').addEventListener('click', exportToJson);
        document.getElementById('clear-results-btn').addEventListener('click', clearResults);
        document.getElementById('retry-btn').addEventListener('click', () => {
            errorSection.style.display = 'none';
        });
        document.getElementById('load-saved-btn').addEventListener('click', showSavedSessions);
        document.getElementById('close-saved-btn').addEventListener('click', () => {
            savedSessionsSection.style.display = 'none';
        });
        document.getElementById('save-results-btn').addEventListener('click', showSaveDialog);
        document.getElementById('confirm-save-btn').addEventListener('click', saveResults);
        document.getElementById('cancel-save-btn').addEventListener('click', () => {
            saveModal.style.display = 'none';
        });

        const stopScrapeBtn = document.getElementById('stop-scrape-btn');
        stopScrapeBtn.addEventListener('click', () => {
            scrapeAborted = true;
            stopScrapeBtn.textContent = 'Stopping...';
            stopScrapeBtn.disabled = true;
        });

        urlInput.addEventListener('keypress', (e) => {
            if (e.key === 'Enter') startScraping();
        });

        // Progress tracking variables
        let progressInterval = null;
        let startTime = null;
        let currentPhase = 0;
        let estimatedAds = 0;

        const phases = [
            { id: 'phase-fetch', text: 'Fetching ads', duration: 120, adsPercent: 60 },
            { id: 'phase-ocr', text: 'Extracting ad text (AI)', duration: 120, adsPercent: 100 }
        ];
        const totalEstimatedTime = phases.reduce((sum, p) => sum + p.duration, 0);

        function updateProgress() {
            const elapsed = (Date.now() - startTime) / 1000;
            const elapsedMin = Math.floor(elapsed / 60);
            const elapsedSec = Math.floor(elapsed % 60);
            document.getElementById('elapsed-time').textContent = `${elapsedMin}:${elapsedSec.toString().padStart(2, '0')}`;

            // Calculate phase and progress
            let accumulatedTime = 0;
            let newPhase = 0;
            for (let i = 0; i < phases.length; i++) {
                if (elapsed >= accumulatedTime + phases[i].duration) {
                    accumulatedTime += phases[i].duration;
                    newPhase = i + 1;
                } else {
                    newPhase = i;
                    break;
                }
            }

            // Update phase indicators
            if (newPhase !== currentPhase && newPhase < phases.length) {
                currentPhase = newPhase;
                phases.forEach((p, i) => {
                    const el = document.getElementById(p.id);
                    if (i < currentPhase) {
                        el.className = 'phase completed';
                        el.querySelector('.phase-icon').textContent = '✓';
                    } else if (i === currentPhase) {
                        el.className = 'phase active';
                        el.querySelector('.phase-icon').textContent = '●';
                    } else {
                        el.className = 'phase';
                        el.querySelector('.phase-icon').textContent = '○';
                    }
                });
                statusSpan.textContent = phases[currentPhase].text;
            }

            // Calculate estimated ads count
            const progressPercent = Math.min((elapsed / totalEstimatedTime) * 100, 95);
            document.getElementById('progress-fill').style.width = `${progressPercent}%`;

            // Estimate ads based on phase
            if (currentPhase < phases.length) {
                const phaseProgress = (elapsed - accumulatedTime) / phases[currentPhase].duration;
                const prevAds = currentPhase > 0 ? phases[currentPhase - 1].adsPercent : 0;
                const targetAds = phases[currentPhase].adsPercent;
                estimatedAds = Math.floor((prevAds + (targetAds - prevAds) * Math.min(phaseProgress, 1)) * 5);
            }
            document.getElementById('ads-count').textContent = `~${estimatedAds} ads`;

            // ETA
            const remaining = Math.max(totalEstimatedTime - elapsed, 0);
            if (remaining > 0) {
                const remMin = Math.floor(remaining / 60);
                const remSec = Math.floor(remaining % 60);
                document.getElementById('eta').textContent = remMin > 0
                    ? `ETA: ${remMin}m ${remSec}s`
                    : `ETA: ${remSec}s`;
            } else {
                document.getElementById('eta').textContent = 'Finishing up...';
            }
        }

        function resetProgress() {
            currentPhase = 0;
            estimatedAds = 0;
            document.getElementById('progress-fill').style.width = '0%';
            document.getElementById('ads-count').textContent = '0 ads';
            document.getElementById('elapsed-time').textContent = '0:00';
            document.getElementById('eta').textContent = 'ETA: calculating...';
            phases.forEach((p, i) => {
                const el = document.getElementById(p.id);
                el.className = i === 0 ? 'phase active' : 'phase';
                el.querySelector('.phase-icon').textContent = i === 0 ? '●' : '○';
            });
            statusSpan.textContent = 'Initializing...';
        }

        async function startScraping() {
            const url = urlInput.value.trim();
            const scraperType = document.getElementById('scraper-select').value;

            if (!url || !url.includes('adstransparency.google.com')) {
                showError('Please enter a valid Google Ads Transparency URL');
                return;
            }

            // Show progress
            startBtn.disabled = true;
            scrapeAborted = false;
            stopScrapeBtn.style.display = 'inline-block';
            stopScrapeBtn.textContent = 'Stop & Save Results';
            stopScrapeBtn.disabled = false;
            progressSection.style.display = 'block';
            resultsSection.style.display = 'none';
            errorSection.style.display = 'none';
            savedSessionsSection.style.display = 'none';

            // Start progress tracking
            resetProgress();
            startTime = Date.now();
            progressInterval = setInterval(updateProgress, 500);

            scrapedAds = [];

            try {
                if (scraperType === 'apify') {
                    // Use Apify scraper (single request, all ads at once)
                    await scrapeWithApify(url);
                } else {
                    // Use SerpAPI scraper (paginated)
                    await scrapeWithSerpApi(url);
                }

                // Stop progress updates
                clearInterval(progressInterval);

                // Mark both phases as complete
                const fetchPhase = document.getElementById('phase-fetch');
                fetchPhase.className = 'phase completed';
                fetchPhase.querySelector('.phase-icon').textContent = '✓';

                const ocrPhase = document.getElementById('phase-ocr');
                ocrPhase.className = 'phase completed';
                ocrPhase.querySelector('.phase-icon').textContent = '✓';

                document.getElementById('ads-count').textContent = `${scrapedAds.length} ads`;

                currentMeta = {
                    url: url,
                    total: scrapedAds.length,
                    scraper: scraperType,
                    visionEnabled: currentMeta.visionEnabled || false,
                    visionStats: currentMeta.visionStats || null,
                    scrapedAt: new Date().toISOString()
                };

                displayResults();

                // All done
                clearInterval(progressInterval);
                document.getElementById('progress-fill').style.width = '100%';

                const ocrCount = scrapedAds.filter(a => a.visionProcessed).length;
                statusSpan.textContent = ocrCount > 0
                    ? `Done! ${scrapedAds.length} ads scraped, ${ocrCount} text extracted.`
                    : `Done! ${scrapedAds.length} ads scraped.`;
                document.getElementById('ads-count').textContent = `${scrapedAds.length} ads`;

            } catch (error) {
                clearInterval(progressInterval);
                if (scrapedAds.length > 0) {
                    // Show partial results
                    currentMeta = {
                        url: url,
                        total: scrapedAds.length,
                        scraper: scraperType,
                        visionEnabled: false,
                        visionStats: null,
                        scrapedAt: new Date().toISOString(),
                        partial: true,
                        error: error.message
                    };
                    displayResults();
                    showNotification(`Partial results: ${scrapedAds.length} ads (${error.message})`);
                } else {
                    showError(error.message);
                }
            } finally {
                startBtn.disabled = false;
                stopScrapeBtn.style.display = 'none';
                progressSection.style.display = 'none';
            }
        }

        // SerpAPI scraper (paginated batches)
        async function scrapeWithSerpApi(url) {
            let pageToken = null;
            let batchNum = 1;
            let hasMorePages = true;

            while (hasMorePages) {
                statusSpan.textContent = `[SerpAPI] Fetching batch ${batchNum} (${scrapedAds.length} ads so far)...`;
                document.getElementById('ads-count').textContent = `${scrapedAds.length} ads`;

                const response = await fetch('/api/scrape', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        url,
                        fetchDetails: batchNum === 1,
                        detailsLimit: 100,
                        enableOcr: false,
                        ocrLimit: 0,
                        maxPages: 50,
                        pageToken: pageToken
                    })
                });

                const contentType = response.headers.get('content-type');
                if (!contentType || !contentType.includes('application/json')) {
                    const text = await response.text();
                    if (text.includes('FUNCTION_INVOCATION_TIMEOUT')) {
                        if (scrapedAds.length > 0) {
                            console.warn('Timeout, continuing with partial results');
                            break;
                        }
                        throw new Error('Request timed out. Try Apify instead.');
                    }
                    throw new Error(text.slice(0, 100) || 'Server error');
                }

                const data = await response.json();
                if (!response.ok) throw new Error(data.error || 'Scraping failed');

                scrapedAds = scrapedAds.concat(data.ads);
                hasMorePages = data.hasMorePages && data.nextPageToken;
                pageToken = data.nextPageToken;
                batchNum++;

                document.getElementById('ads-count').textContent = `${scrapedAds.length} ads`;

                if (hasMorePages) {
                    await new Promise(r => setTimeout(r, 1000));
                }
            }
        }

        // Apify scraper (async with polling + parallel OCR pipeline)
        async function scrapeWithApify(url) {
            const maxResults = parseInt(document.getElementById('max-results').value) || 100;
            statusSpan.textContent = `[Apify] Starting scraper (max ${maxResults} ads)...`;
            document.getElementById('ads-count').textContent = 'Initializing...';

            // Start the run
            const startResponse = await fetch('/api/scrape-apify', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({
                    url,
                    maxResults: maxResults
                })
            });

            const startData = await startResponse.json();
            if (!startResponse.ok && startResponse.status !== 202) {
                throw new Error(startData.error || 'Failed to start Apify scraper');
            }

            const runId = startData.runId;
            if (!runId) {
                throw new Error('No run ID returned');
            }

            console.log('Apify run started:', runId);
            statusSpan.textContent = '[Apify] Scraping in progress...';

            // Show results section early
            resultsSection.style.display = 'block';
            totalCount.textContent = '0';
            resultsTableBody.innerHTML = '<tr><td colspan="10" style="text-align: center; color: #667eea; padding: 40px;"><div class="scraping-indicator">Scraping in progress... Ads will appear here as they are collected.</div></td></tr>';

            // Parallel pipeline state
            let lastFetchedOffset = 0;
            const BATCH_SIZE = 100;
            let pendingOcrPromises = [];
            let ocrProcessedIds = new Set();
            let ocrSuccessful = 0;
            let ocrFailed = 0;
            let ocrAttempted = 0;
            let runFinished = false;

            // OCR helper: fire OCR for a batch of ads (returns a Promise)
            function fireOcrBatch(adsBatch) {
                const batchData = adsBatch.map(ad => ({ id: ad.id, imageUrl: ad.image || ad.imageUrl }));
                adsBatch.forEach(ad => ocrProcessedIds.add(ad.id));
                ocrAttempted += adsBatch.length;

                return fetch('/api/ocr-batch', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ ads: batchData })
                }).then(async (response) => {
                    const contentType = response.headers.get('content-type');
                    if (!contentType || !contentType.includes('application/json')) {
                        throw new Error('Server error during OCR');
                    }
                    const data = await response.json();
                    if (data.error) throw new Error(data.error);

                    if (data.results) {
                        data.results.forEach(result => {
                            const ad = scrapedAds.find(a => a.id === result.id);
                            if (!ad) return;
                            if (result.success && result.data) {
                                if (result.data.headline && !ad.headline) ad.headline = result.data.headline;
                                if (result.data.description && !ad.description) ad.description = result.data.description;
                                if (result.data.callToAction && !ad.callToAction) ad.callToAction = result.data.callToAction;
                                if (result.data.visibleUrl && !ad.visibleLink) ad.visibleLink = result.data.visibleUrl;
                                if (result.data.brandName) ad.brandName = result.data.brandName;
                                if (result.data.allText) ad.extractedText = result.data.allText;
                                ad.visionProcessed = true;
                                ocrSuccessful++;
                            } else {
                                ad.visionProcessed = true;
                                ad.visionError = result.error || 'Unknown error';
                                ocrFailed++;
                            }
                        });
                    }
                    // Update display after OCR batch completes
                    updatePipelineStatus();
                    displayPartialResults(scrapedAds, scrapedAds.length, !runFinished);
                }).catch(err => {
                    console.error('OCR batch error:', err);
                    ocrFailed += adsBatch.length;
                });
            }

            // Update the status line for parallel pipeline
            function updatePipelineStatus() {
                const ocrTotal = ocrAttempted;
                const ocrDone = ocrSuccessful + ocrFailed;
                if (ocrTotal > 0) {
                    statusSpan.textContent = `Fetched: ${scrapedAds.length} ads | OCR: ${ocrDone}/${ocrTotal} processed`;
                } else {
                    statusSpan.textContent = `Fetched: ${scrapedAds.length} ads`;
                }
                document.getElementById('ads-count').textContent = `${scrapedAds.length} ads`;
                totalCount.textContent = scrapedAds.length;
            }

            // Helper: add new ads to scrapedAds, capped at maxResults. Returns the ads actually added.
            function addNewAds(newAds) {
                const remaining = maxResults - scrapedAds.length;
                if (remaining <= 0) return [];
                const toAdd = newAds.slice(0, remaining);
                scrapedAds = scrapedAds.concat(toAdd);
                lastFetchedOffset += newAds.length; // advance offset by full fetch (even if we cap)
                return toAdd;
            }

            // Helper: fire OCR for newly added ads that have images
            function ocrNewAds(addedAds) {
                const withImages = addedAds.filter(
                    ad => (ad.image || ad.imageUrl) && !ocrProcessedIds.has(ad.id)
                );
                if (withImages.length > 0 && !scrapeAborted) {
                    pendingOcrPromises.push(fireOcrBatch(withImages));
                }
            }

            // Poll loop
            let attempts = 0;
            const maxAttempts = 720;  // 60 minutes max (5s intervals)

            while (attempts < maxAttempts && !scrapeAborted) {
                // Stop early if we already have enough
                if (scrapedAds.length >= maxResults) {
                    console.log(`Already have ${scrapedAds.length}/${maxResults} ads, stopping.`);
                    runFinished = true;
                    break;
                }

                await new Promise(r => setTimeout(r, 5000));
                if (scrapeAborted) break;
                attempts++;

                try {
                    // Only fetch what we still need
                    const needed = maxResults - scrapedAds.length;
                    const fetchLimit = Math.min(BATCH_SIZE, needed);

                    const pollResponse = await fetch('/api/scrape-apify', {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({
                            runId,
                            includePartialResults: true,
                            offset: lastFetchedOffset,
                            limit: fetchLimit
                        })
                    });

                    const pollData = await pollResponse.json();
                    const totalInDataset = pollData.total || pollData.stats?.itemsScraped || 0;

                    // Add new ads (capped)
                    if (pollData.partialAds && pollData.partialAds.length > 0) {
                        const added = addNewAds(pollData.partialAds);
                        ocrNewAds(added);
                        updatePipelineStatus();
                        displayPartialResults(scrapedAds, Math.min(totalInDataset, maxResults), true);
                    }

                    // Check if we've hit the cap
                    if (scrapedAds.length >= maxResults) {
                        console.log(`Reached ${maxResults} cap after fetch.`);
                        runFinished = true;
                        break;
                    }

                    if (pollData.status === 'RUNNING' || pollData.status === 'READY') {
                        continue;
                    }

                    if (pollData.status === 'SUCCEEDED' || pollData.status === 'TIMED-OUT') {
                        // Run finished - fetch remaining ads up to cap
                        while (scrapedAds.length < maxResults && lastFetchedOffset < totalInDataset) {
                            const needed2 = maxResults - scrapedAds.length;
                            const finalResponse = await fetch('/api/scrape-apify', {
                                method: 'POST',
                                headers: { 'Content-Type': 'application/json' },
                                body: JSON.stringify({
                                    runId,
                                    includePartialResults: true,
                                    offset: lastFetchedOffset,
                                    limit: Math.min(BATCH_SIZE, needed2)
                                })
                            });
                            const finalData = await finalResponse.json();
                            if (finalData.partialAds && finalData.partialAds.length > 0) {
                                const added = addNewAds(finalData.partialAds);
                                ocrNewAds(added);
                            } else {
                                break;
                            }
                        }

                        if (pollData.status === 'TIMED-OUT' && scrapedAds.length > 0) {
                            console.warn('Apify run timed out but got partial results:', scrapedAds.length);
                        }
                        runFinished = true;
                        break;
                    }

                    // Failed
                    throw new Error(`Apify run ${pollData.status}: ${pollData.error || 'Unknown error'}`);

                } catch (pollError) {
                    console.error('Poll error:', pollError);
                    if (attempts >= maxAttempts) throw pollError;
                }
            }

            // Wait for all pending OCR promises to finish
            if (pendingOcrPromises.length > 0) {
                statusSpan.textContent = `Waiting for ${pendingOcrPromises.length} OCR batches to finish...`;
                await Promise.allSettled(pendingOcrPromises);
            }

            // Update vision stats
            currentMeta.visionStats = { successful: ocrSuccessful, attempted: ocrAttempted, failed: ocrFailed };
            currentMeta.visionEnabled = ocrAttempted > 0;

            // If aborted, use whatever we have
            if (scrapeAborted && scrapedAds.length > 0) {
                document.getElementById('ads-count').textContent = `${scrapedAds.length} ads (stopped)`;
                totalCount.textContent = scrapedAds.length;
                console.log(`Scraping stopped by user with ${scrapedAds.length} partial results`);
                return;
            }

            if (scrapedAds.length === 0 && !scrapeAborted) {
                throw new Error('Apify scraping timed out after 60 minutes');
            }

            updatePipelineStatus();
        }

        // Display partial results during scraping
        function displayPartialResults(ads, totalExpected, isStillScraping) {
            resultsTableBody.innerHTML = '';

            // Show first 50 ads as preview
            const previewAds = ads.slice(0, 50);

            previewAds.forEach(ad => {
                const row = createAdRow(ad);
                resultsTableBody.appendChild(row);
            });

            // Add "more loading" row if still scraping
            if (isStillScraping) {
                const loadingRow = document.createElement('tr');
                loadingRow.className = 'loading-more-row';
                loadingRow.innerHTML = `
                    <td colspan="10" style="text-align: center; padding: 20px; background: linear-gradient(135deg, #e8f5e9 0%, #e3f2fd 100%);">
                        <div style="color: #667eea; font-weight: 600;">
                            ⏳ <span style="font-size: 18px;">${totalExpected}</span> ads collected so far... Still scraping!
                            <br><small style="font-weight: normal; color: #666;">Showing preview of first ${ads.length} ads</small>
                        </div>
                    </td>
                `;
                resultsTableBody.appendChild(loadingRow);
            }
        }

        // Determine OCR status for an ad
        function getOcrStatus(ad) {
            const hasImage = ad.image || ad.imageUrl;
            if (!hasImage) return { status: 'no-image', label: '-', cls: '' };
            const hasText = (ad.headline && ad.headline !== '-') || (ad.description && ad.description !== '-') || ad.extractedText;
            if (hasText) return { status: 'success', label: 'OK', cls: 'ocr-ok' };
            if (ad.visionProcessed) return { status: 'failed', label: 'Failed', cls: 'ocr-failed' };
            return { status: 'pending', label: 'Pending', cls: 'ocr-pending' };
        }

        // Create a table row for an ad (reusable function)
        function createAdRow(ad) {
            const row = document.createElement('tr');
            row.dataset.adId = ad.id;

            // Image
            const imageHtml = ad.image || ad.imageUrl
                ? `<img src="${ad.image || ad.imageUrl}" alt="Ad" class="ad-thumbnail" onerror="this.src='data:image/svg+xml,<svg xmlns=%22http://www.w3.org/2000/svg%22 width=%2260%22 height=%2260%22><rect fill=%22%23f0f0f0%22 width=%2260%22 height=%2260%22/><text x=%2230%22 y=%2235%22 text-anchor=%22middle%22 fill=%22%23999%22 font-size=%2210%22>No img</text></svg>'">`
                : '<span class="no-image">-</span>';

            const advertiserName = ad.adFundedBy || ad.advertiser || 'Unknown';
            const titleHeadline = ad.headline || ad.title || '-';
            const descSnippet = ad.description || ad.text || '-';
            const visionBadge = ad.visionProcessed ? '<span class="vision-badge">AI</span>' : '';

            const visibleLink = ad.visibleLink || ad.displayUrl || ad.destinationUrl || '';
            const visibleLinkHtml = visibleLink
                ? `<a href="${ad.destinationUrl || visibleLink}" target="_blank" rel="noopener" class="visible-link">${escapeHtml(truncateUrl(visibleLink, 35))}</a>`
                : '-';

            const detailsHtml = ad.detailsLink
                ? `<a href="${ad.detailsLink}" target="_blank" rel="noopener" class="btn btn-small">View</a>`
                : '-';

            const textTooltip = ad.extractedText
                ? `title="${escapeHtml(ad.extractedText.substring(0, 500))}"`
                : '';

            // OCR status
            const ocr = getOcrStatus(ad);
            const ocrHtml = ocr.status === 'no-image' ? '-' : `<span class="ocr-status-badge ${ocr.cls}">${ocr.label}</span>`;

            row.innerHTML = `
                <td class="checkbox-col"><input type="checkbox" class="ad-checkbox" data-ad-id="${ad.id}"></td>
                <td>${imageHtml}</td>
                <td>
                    <strong>${escapeHtml(advertiserName)}</strong>
                    <div class="sub-info">${escapeHtml(ad.advertiserId || '')}</div>
                </td>
                <td class="text-cell" ${textTooltip}>${visionBadge}${escapeHtml(titleHeadline)}</td>
                <td class="text-cell">${escapeHtml(descSnippet)}</td>
                <td class="url-cell">${visibleLinkHtml}</td>
                <td><span class="badge badge-${(ad.format || 'unknown').toLowerCase()}">${ad.format || 'Unknown'}</span></td>
                <td class="date-cell">${ad.dateRange || '-'}</td>
                <td class="ocr-cell">${ocrHtml}</td>
                <td>${detailsHtml}</td>
            `;

            return row;
        }

        function displayResults() {
            resultsTableBody.innerHTML = '';
            totalCount.textContent = scrapedAds.length;

            // Count OCR statuses
            const adsWithImages = scrapedAds.filter(ad => ad.image || ad.imageUrl);
            const adsProcessed = adsWithImages.filter(ad => ad.visionProcessed);
            const adsFailed = adsWithImages.filter(ad => getOcrStatus(ad).status === 'failed');
            const adsOk = adsWithImages.filter(ad => getOcrStatus(ad).status === 'success');

            // Show vision stats
            if (adsProcessed.length > 0) {
                visionStats.innerHTML = `<span class="vision-badge">AI OCR: ${adsOk.length}/${adsWithImages.length} OK</span>`;
            } else {
                visionStats.innerHTML = '';
            }

            // Update OCR controls
            const ocrProgressEl = document.getElementById('ocr-progress');
            if (ocrProgressEl) {
                ocrProgressEl.textContent = `${adsProcessed.length}/${adsWithImages.length}`;
            }
            const ocrControls = document.getElementById('ocr-controls');
            if (ocrControls) {
                ocrControls.style.display = adsWithImages.length > 0 ? 'flex' : 'none';
            }

            // Show/hide failed count and re-run failed button
            const failedCountEl = document.getElementById('ocr-failed-count');
            const rerunFailedBtn = document.getElementById('rerun-failed-btn');
            if (adsFailed.length > 0) {
                failedCountEl.textContent = `${adsFailed.length} failed`;
                failedCountEl.style.display = 'inline';
                rerunFailedBtn.style.display = 'inline-block';
            } else {
                failedCountEl.style.display = 'none';
                rerunFailedBtn.style.display = 'none';
            }

            // Show metadata
            if (currentMeta.url) {
                resultsMeta.innerHTML = `
                    <span class="meta-item">Source: ${escapeHtml(extractDomain(currentMeta.url))}</span>
                    <span class="meta-item">Scraped: ${new Date(currentMeta.scrapedAt).toLocaleString()}</span>
                `;
            }

            if (scrapedAds.length === 0) {
                resultsTableBody.innerHTML = '<tr><td colspan="10" style="text-align: center; color: #666;">No ads found</td></tr>';
                resultsSection.style.display = 'block';
                return;
            }

            scrapedAds.forEach(ad => {
                const row = createAdRow(ad);
                resultsTableBody.appendChild(row);
            });

            resultsSection.style.display = 'block';

            // Reset select-all checkbox
            const selectAll = document.getElementById('select-all-ads');
            if (selectAll) selectAll.checked = false;
            updateSelectedCount();
        }

        // Save/Load Functions (using IndexedDB for large storage)
        function showSaveDialog() {
            if (scrapedAds.length === 0) {
                showError('No data to save');
                return;
            }
            const domain = extractDomain(currentMeta.url || urlInput.value);
            saveNameInput.value = `${domain} - ${new Date().toLocaleDateString()}`;
            saveModal.style.display = 'flex';
        }

        async function saveResults() {
            const name = saveNameInput.value.trim() || `Session ${new Date().toLocaleString()}`;

            const session = {
                id: Date.now(),
                name: name,
                url: currentMeta.url || urlInput.value,
                adsCount: scrapedAds.length,
                visionStats: currentMeta.visionStats,
                savedAt: new Date().toISOString(),
                ads: scrapedAds,
                meta: currentMeta
            };

            try {
                if (!db) await initDB();
                await saveSessionToDB(session);
                saveModal.style.display = 'none';
                showNotification(`Saved "${name}" successfully!`);
            } catch (e) {
                showError('Failed to save: ' + e.message);
            }
        }

        async function showSavedSessions() {
            savedSessionsList.innerHTML = '<p class="no-saved">Loading...</p>';
            savedSessionsSection.style.display = 'block';

            try {
                if (!db) await initDB();
                const sessions = await getAllSessionsFromDB();

                savedSessionsList.innerHTML = '';

                if (sessions.length === 0) {
                    savedSessionsList.innerHTML = '<p class="no-saved">No saved sessions found</p>';
                } else {
                    // Calculate total storage used
                    let totalSize = 0;
                    sessions.forEach(s => {
                        totalSize += JSON.stringify(s).length;
                    });
                    const sizeMB = (totalSize / 1024 / 1024).toFixed(1);

                    const storageInfo = document.createElement('div');
                    storageInfo.className = 'storage-info';
                    storageInfo.innerHTML = `<span>${sessions.length} sessions • ${sizeMB} MB used</span>`;
                    savedSessionsList.appendChild(storageInfo);

                    sessions.forEach(session => {
                        const ocrCount = session.ads?.filter(a => a.visionProcessed).length || 0;
                        const item = document.createElement('div');
                        item.className = 'saved-session-item';
                        item.innerHTML = `
                            <div class="session-info">
                                <strong>${escapeHtml(session.name)}</strong>
                                <span class="session-meta">${session.adsCount} ads${ocrCount > 0 ? ` • ${ocrCount} OCR'd` : ''} • ${new Date(session.savedAt).toLocaleString()}</span>
                            </div>
                            <div class="session-actions">
                                <button class="btn btn-small btn-primary" onclick="loadSession(${session.id})">Load</button>
                                <button class="btn btn-small btn-danger" onclick="deleteSession(${session.id})">Delete</button>
                            </div>
                        `;
                        savedSessionsList.appendChild(item);
                    });
                }
            } catch (e) {
                savedSessionsList.innerHTML = `<p class="no-saved">Error loading sessions: ${e.message}</p>`;
            }
        }

        async function loadSession(id) {
            try {
                if (!db) await initDB();
                const session = await getSessionFromDB(id);

                if (session) {
                    scrapedAds = session.ads;
                    currentMeta = session.meta || {
                        url: session.url,
                        visionStats: session.visionStats,
                        scrapedAt: session.savedAt
                    };
                    urlInput.value = session.url || '';
                    displayResults();
                    savedSessionsSection.style.display = 'none';
                    showNotification(`Loaded "${session.name}"`);
                }
            } catch (e) {
                showError('Failed to load session: ' + e.message);
            }
        }

        async function deleteSession(id) {
            if (!confirm('Delete this saved session?')) return;

            try {
                if (!db) await initDB();
                await deleteSessionFromDB(id);
                showSavedSessions();
            } catch (e) {
                showError('Failed to delete: ' + e.message);
            }
        }

        function showNotification(message) {
            const notif = document.createElement('div');
            notif.className = 'notification';
            notif.textContent = message;
            document.body.appendChild(notif);
            setTimeout(() => notif.remove(), 3000);
        }

        function extractDomain(url) {
            try {
                const match = url.match(/domain=([^&]+)/);
                if (match) return match[1];
                const advMatch = url.match(/advertiser\/(AR\d+)/);
                if (advMatch) return `Advertiser ${advMatch[1].slice(0, 10)}...`;
                return 'Unknown';
            } catch {
                return 'Unknown';
            }
        }

        function exportToExcel() {
            if (scrapedAds.length === 0) {
                showError('No data to export');
                return;
            }

            const wsData = [
                [
                    'Advertiser',
                    'Ad Funded By',
                    'Advertiser ID',
                    'Creative ID',
                    'Title',
                    'Headline',
                    'Description/Snippet',
                    'Call To Action',
                    'Visible Link',
                    'Destination URL',
                    'AI Extracted Text',
                    'AI Processed',
                    'Format',
                    'Image URL',
                    'Video URL',
                    'Region',
                    'First Shown',
                    'Last Shown',
                    'Days Shown',
                    'Details Link',
                    'Scraped At'
                ]
            ];

            scrapedAds.forEach(ad => {
                wsData.push([
                    ad.advertiser || '',
                    ad.adFundedBy || '',
                    ad.advertiserId || '',
                    ad.creativeId || '',
                    ad.title || '',
                    ad.headline || '',
                    ad.description || ad.text || '',
                    ad.callToAction || '',
                    ad.visibleLink || ad.displayUrl || '',
                    ad.destinationUrl || '',
                    ad.extractedText || '',
                    ad.visionProcessed ? 'Yes' : 'No',
                    ad.format || '',
                    ad.image || ad.imageUrl || '',
                    ad.videoUrl || '',
                    ad.regionName || '',
                    ad.firstShown || '',
                    ad.lastShown || '',
                    ad.totalDaysShown || '',
                    ad.detailsLink || '',
                    currentMeta.scrapedAt || new Date().toISOString()
                ]);
            });

            const ws = XLSX.utils.aoa_to_sheet(wsData);
            ws['!cols'] = [
                { wch: 25 }, { wch: 25 }, { wch: 25 }, { wch: 25 },
                { wch: 40 }, { wch: 50 }, { wch: 60 }, { wch: 15 },
                { wch: 35 }, { wch: 50 }, { wch: 80 }, { wch: 12 },
                { wch: 10 }, { wch: 60 }, { wch: 60 }, { wch: 15 },
                { wch: 12 }, { wch: 12 }, { wch: 10 }, { wch: 60 }, { wch: 20 }
            ];

            const wb = XLSX.utils.book_new();
            XLSX.utils.book_append_sheet(wb, ws, 'Scraped Ads');

            const domain = extractDomain(currentMeta.url || urlInput.value);
            const timestamp = new Date().toISOString().slice(0, 10);
            XLSX.writeFile(wb, `ads-${domain}-${timestamp}.xlsx`);
        }

        function exportToJson() {
            if (scrapedAds.length === 0) {
                showError('No data to export');
                return;
            }

            const exportData = {
                meta: currentMeta,
                ads: scrapedAds
            };

            const dataStr = JSON.stringify(exportData, null, 2);
            const blob = new Blob([dataStr], { type: 'application/json' });
            const url = window.URL.createObjectURL(blob);
            const link = document.createElement('a');
            link.href = url;
            const domain = extractDomain(currentMeta.url || urlInput.value);
            const timestamp = new Date().toISOString().slice(0, 10);
            link.download = `ads-${domain}-${timestamp}.json`;
            document.body.appendChild(link);
            link.click();
            document.body.removeChild(link);
            window.URL.revokeObjectURL(url);
        }

        function clearResults() {
            scrapedAds = [];
            currentMeta = {};
            resultsSection.style.display = 'none';
            urlInput.value = '';
        }

        function showError(message) {
            errorText.textContent = message;
            errorSection.style.display = 'block';
            progressSection.style.display = 'none';
        }

        function escapeHtml(text) {
            if (!text) return '';
            const div = document.createElement('div');
            div.textContent = text;
            return div.innerHTML;
        }

        function truncateUrl(url, maxLength) {
            if (!url || url.length <= maxLength) return url;
            return url.substring(0, maxLength) + '...';
        }

        // Make functions available globally for onclick handlers
        window.loadSession = loadSession;
        window.deleteSession = deleteSession;

        // ===== CHECKBOX SELECTION =====
        function updateSelectedCount() {
            const checked = document.querySelectorAll('.ad-checkbox:checked');
            const rerunSelectedBtn = document.getElementById('rerun-selected-btn');
            if (rerunSelectedBtn) {
                if (checked.length > 0) {
                    rerunSelectedBtn.textContent = `Re-run Selected (${checked.length})`;
                    rerunSelectedBtn.style.display = 'inline-block';
                } else {
                    rerunSelectedBtn.style.display = 'none';
                }
            }
        }

        // Select-all checkbox
        document.getElementById('select-all-ads')?.addEventListener('change', function() {
            const checkboxes = document.querySelectorAll('.ad-checkbox');
            checkboxes.forEach(cb => cb.checked = this.checked);
            updateSelectedCount();
        });

        // Delegate checkbox change events
        document.getElementById('results-tbody')?.addEventListener('change', function(e) {
            if (e.target.classList.contains('ad-checkbox')) {
                updateSelectedCount();
                // Uncheck select-all if any individual is unchecked
                const allBoxes = document.querySelectorAll('.ad-checkbox');
                const allChecked = [...allBoxes].every(cb => cb.checked);
                document.getElementById('select-all-ads').checked = allChecked;
            }
        });

        // ===== BATCHED OCR PROCESSING =====
        let ocrRunning = false;
        let ocrAborted = false;
        let retryCount = 0;
        const MAX_RETRIES = 3;

        document.getElementById('rerun-failed-btn')?.addEventListener('click', () => rerunOcrForAds('failed'));
        document.getElementById('rerun-selected-btn')?.addEventListener('click', () => rerunOcrForAds('selected'));
        document.getElementById('stop-ocr-btn')?.addEventListener('click', stopOcr);

        function stopOcr() {
            ocrAborted = true;
            document.getElementById('ocr-status').textContent = 'Stopping...';
        }

        // Rerun OCR for failed or selected ads
        async function rerunOcrForAds(mode) {
            if (ocrRunning || scrapedAds.length === 0) return;

            let adsToProcess = [];
            if (mode === 'failed') {
                // Get ads where OCR was attempted but no text was extracted
                adsToProcess = scrapedAds.filter(ad => {
                    const ocr = getOcrStatus(ad);
                    return ocr.status === 'failed';
                });
            } else if (mode === 'selected') {
                const checkedIds = [...document.querySelectorAll('.ad-checkbox:checked')].map(cb => cb.dataset.adId);
                adsToProcess = scrapedAds.filter(ad => checkedIds.includes(String(ad.id)));
            }

            if (adsToProcess.length === 0) {
                document.getElementById('ocr-status').textContent = 'No ads to process.';
                return;
            }

            // Reset visionProcessed so they get re-processed
            adsToProcess.forEach(ad => {
                ad.visionProcessed = false;
                ad.headline = '';
                ad.description = '';
                ad.extractedText = '';
                ad.visionError = null;
            });

            await runBatchedOcr(adsToProcess);
        }

        async function runBatchedOcr(adsToOcr) {
            if (ocrRunning) return;

            ocrRunning = true;
            ocrAborted = false;
            retryCount = 0;

            const stopOcrBtn = document.getElementById('stop-ocr-btn');
            const rerunFailedBtn = document.getElementById('rerun-failed-btn');
            const rerunSelectedBtn = document.getElementById('rerun-selected-btn');
            const ocrStatus = document.getElementById('ocr-status');
            const ocrProgressEl = document.getElementById('ocr-progress');

            stopOcrBtn.style.display = 'inline-block';
            rerunFailedBtn.style.display = 'none';
            rerunSelectedBtn.style.display = 'none';

            const totalToProcess = adsToOcr.length;
            ocrStatus.textContent = `Starting OCR for ${totalToProcess} ads...`;

            const batchSize = 100;
            let processed = 0;
            let successful = 0;
            let failed = 0;
            let errors = [];

            for (let i = 0; i < adsToOcr.length && !ocrAborted; i += batchSize) {
                const batch = adsToOcr.slice(i, i + batchSize);
                const batchData = batch.map(ad => ({
                    id: ad.id,
                    imageUrl: ad.image || ad.imageUrl
                }));

                const batchNum = Math.floor(i / batchSize) + 1;
                const totalBatches = Math.ceil(adsToOcr.length / batchSize);
                ocrStatus.textContent = `Batch ${batchNum}/${totalBatches} (${batch.length} ads)...`;

                try {
                    const response = await fetch('/api/ocr-batch', {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({ ads: batchData })
                    });

                    const contentType = response.headers.get('content-type');
                    if (!contentType || !contentType.includes('application/json')) {
                        const text = await response.text();
                        throw new Error(text.slice(0, 100) || 'Server error');
                    }

                    const data = await response.json();
                    if (data.error) throw new Error(data.error);

                    if (data.results) {
                        data.results.forEach(result => {
                            const ad = scrapedAds.find(a => a.id === result.id);
                            if (!ad) return;

                            if (result.success && result.data) {
                                if (result.data.headline) ad.headline = result.data.headline;
                                if (result.data.description) ad.description = result.data.description;
                                if (result.data.callToAction) ad.callToAction = result.data.callToAction;
                                if (result.data.visibleUrl) ad.visibleLink = result.data.visibleUrl;
                                if (result.data.brandName) ad.brandName = result.data.brandName;
                                if (result.data.allText) ad.extractedText = result.data.allText;
                                ad.visionProcessed = true;
                                successful++;
                            } else {
                                ad.visionProcessed = true;
                                ad.visionError = result.error || 'Unknown error';
                                failed++;
                                if (errors.length < 5) errors.push(result.error);
                            }
                        });
                    }

                    processed += batch.length;
                    retryCount = 0;

                    ocrProgressEl.textContent = `${processed}/${totalToProcess}`;

                    // Refresh display periodically
                    if (batchNum % 3 === 0 || i + batchSize >= adsToOcr.length) {
                        displayResults();
                    }

                } catch (error) {
                    console.error('Batch OCR error:', error);
                    retryCount++;

                    if (retryCount >= MAX_RETRIES) {
                        ocrStatus.textContent = `Failed after ${MAX_RETRIES} retries: ${error.message}. Skipping batch.`;
                        processed += batch.length;
                        failed += batch.length;
                        retryCount = 0;
                        await new Promise(r => setTimeout(r, 2000));
                    } else {
                        ocrStatus.textContent = `Error: ${error.message}. Retry ${retryCount}/${MAX_RETRIES} in 5s...`;
                        await new Promise(r => setTimeout(r, 5000));
                        i -= batchSize;
                    }
                }
            }

            ocrRunning = false;
            stopOcrBtn.style.display = 'none';

            // Final display refresh
            displayResults();

            if (ocrAborted) {
                ocrStatus.textContent = `Stopped. ${processed}/${totalToProcess} processed (${successful} OK, ${failed} failed)`;
            } else {
                ocrStatus.textContent = `Done! ${successful}/${totalToProcess} succeeded. ${failed > 0 ? `${failed} still failed.` : ''}`;
            }

            ocrAborted = false;
        }
    </script>

    <style>
        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.5; }
        }

        /* Progress Section Styles */
        .progress-info {
            padding: 10px 0;
        }

        .progress-info h3 {
            margin-bottom: 15px;
            color: #333;
        }

        .progress-bar {
            height: 8px;
            background: #e0e0e0;
            border-radius: 4px;
            overflow: hidden;
            margin-bottom: 15px;
        }

        #progress-fill {
            height: 100%;
            background: linear-gradient(90deg, #667eea 0%, #764ba2 100%);
            border-radius: 4px;
            transition: width 0.3s ease;
            width: 0%;
        }

        .progress-details {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 20px;
            flex-wrap: wrap;
            gap: 10px;
        }

        .progress-stats {
            font-size: 14px;
            color: #333;
            font-weight: 500;
        }

        .progress-numbers {
            display: flex;
            gap: 8px;
            font-size: 13px;
            color: #666;
        }

        .progress-numbers .separator {
            color: #ccc;
        }

        #ads-count {
            font-weight: 600;
            color: #667eea;
        }

        #eta {
            color: #888;
        }

        .progress-phases {
            display: flex;
            flex-direction: column;
            gap: 8px;
            padding: 15px;
            background: #f8f9fa;
            border-radius: 8px;
        }

        .phase {
            display: flex;
            align-items: center;
            gap: 10px;
            font-size: 13px;
            color: #999;
            transition: all 0.3s ease;
        }

        .phase.active {
            color: #667eea;
            font-weight: 500;
        }

        .phase.active .phase-icon {
            animation: pulse 1s infinite;
        }

        .phase.completed {
            color: #28a745;
        }

        .phase.completed .phase-icon {
            color: #28a745;
        }

        .phase-icon {
            width: 16px;
            text-align: center;
            font-size: 10px;
        }

        footer {
            text-align: center;
            padding: 20px;
            color: #666;
            font-size: 14px;
        }

        footer a {
            color: #667eea;
            text-decoration: none;
        }

        footer a:hover {
            text-decoration: underline;
        }

        .example-urls {
            margin-top: 15px;
            padding: 10px;
            background: #f8f9fa;
            border-radius: 6px;
            font-size: 14px;
        }

        .example-urls code {
            display: block;
            margin-top: 5px;
            padding: 8px;
            background: #e9ecef;
            border-radius: 4px;
            word-break: break-all;
            cursor: pointer;
        }

        .example-urls code:hover {
            background: #dee2e6;
        }

        .error-section {
            background: white;
            padding: 30px;
            border-radius: 10px;
            box-shadow: 0 2px 10px rgba(0, 0, 0, 0.1);
            margin-bottom: 30px;
            border-left: 4px solid #ff6b6b;
        }

        .error-message h3 {
            color: #ff6b6b;
            margin-bottom: 10px;
        }

        .badge {
            padding: 4px 8px;
            border-radius: 12px;
            font-size: 11px;
            font-weight: 600;
            text-transform: uppercase;
            white-space: nowrap;
        }

        .badge-text { background: #e3f2fd; color: #1976d2; }
        .badge-display { background: #f3e5f5; color: #7b1fa2; }
        .badge-video { background: #e8f5e9; color: #388e3c; }
        .badge-image { background: #fff3e0; color: #e65100; }
        .badge-unknown { background: #f5f5f5; color: #666; }

        .vision-badge {
            display: inline-block;
            padding: 2px 6px;
            font-size: 10px;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            border-radius: 3px;
            margin-right: 4px;
            font-weight: 600;
            vertical-align: middle;
        }

        .vision-stats {
            font-weight: normal;
            margin-left: 10px;
        }

        .results-meta {
            display: flex;
            gap: 20px;
            margin-bottom: 15px;
            font-size: 13px;
            color: #666;
        }

        .meta-item {
            background: #f8f9fa;
            padding: 4px 10px;
            border-radius: 4px;
        }

        .ad-thumbnail {
            width: 60px;
            height: 60px;
            object-fit: cover;
            border-radius: 4px;
            border: 1px solid #e0e0e0;
        }

        .no-image {
            display: inline-block;
            width: 60px;
            height: 60px;
            line-height: 60px;
            text-align: center;
            background: #f5f5f5;
            border-radius: 4px;
            color: #999;
        }

        .sub-info {
            font-size: 10px;
            color: #888;
            margin-top: 4px;
            word-break: break-all;
        }

        .text-cell {
            max-width: 200px;
            overflow: hidden;
            text-overflow: ellipsis;
            font-size: 13px;
        }

        .url-cell {
            max-width: 150px;
        }

        .visible-link {
            font-size: 12px;
            color: #1976d2;
            word-break: break-all;
            text-decoration: none;
        }

        .visible-link:hover {
            text-decoration: underline;
        }

        .date-cell {
            font-size: 12px;
            white-space: nowrap;
        }

        .btn-small {
            padding: 4px 8px;
            font-size: 11px;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            border: none;
            border-radius: 4px;
            text-decoration: none;
            cursor: pointer;
        }

        .btn-small:hover {
            opacity: 0.9;
        }

        .btn-small.btn-secondary {
            background: #6c757d;
        }

        .btn-small.btn-danger {
            background: linear-gradient(135deg, #ff6b6b 0%, #ee5a52 100%);
        }

        .btn-danger {
            background: linear-gradient(135deg, #ff6b6b 0%, #ee5a52 100%);
            color: white;
            border: none;
            padding: 10px 20px;
            border-radius: 6px;
            cursor: pointer;
            font-size: 14px;
            font-weight: 600;
        }

        .btn-danger:hover {
            opacity: 0.9;
        }

        .btn-warning {
            background: linear-gradient(135deg, #ffc107 0%, #ff9800 100%);
            color: #333;
        }

        #results-table {
            font-size: 13px;
        }

        #results-table th {
            position: sticky;
            top: 0;
            background: #f8f9fa;
            z-index: 1;
        }

        .results-table-container {
            max-height: 600px;
            overflow-y: auto;
        }

        .results-actions {
            display: flex;
            gap: 10px;
            flex-wrap: wrap;
        }

        /* Saved Sessions */
        .saved-sessions-section {
            background: white;
            padding: 20px;
            border-radius: 10px;
            box-shadow: 0 2px 10px rgba(0, 0, 0, 0.1);
            margin-bottom: 20px;
        }

        .saved-sessions-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 15px;
        }

        .saved-sessions-header h3 {
            margin: 0;
        }

        .saved-session-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 12px;
            border: 1px solid #e0e0e0;
            border-radius: 6px;
            margin-bottom: 8px;
        }

        .saved-session-item:hover {
            background: #f8f9fa;
        }

        .session-info strong {
            display: block;
            margin-bottom: 4px;
        }

        .session-meta {
            font-size: 12px;
            color: #666;
        }

        .session-actions {
            display: flex;
            gap: 8px;
        }

        .no-saved {
            color: #666;
            text-align: center;
            padding: 20px;
        }

        .storage-info {
            background: #e3f2fd;
            padding: 8px 12px;
            border-radius: 6px;
            margin-bottom: 12px;
            font-size: 13px;
            color: #1565c0;
        }

        /* Scraper selection */
        .scraper-options {
            display: flex;
            align-items: center;
            gap: 10px;
            margin: 10px 0;
        }

        .scraper-options label {
            font-weight: 600;
            color: #333;
        }

        #scraper-select {
            padding: 8px 12px;
            border: 2px solid #e0e0e0;
            border-radius: 6px;
            font-size: 14px;
            background: white;
            cursor: pointer;
            flex: 1;
            max-width: 300px;
        }

        #scraper-select:focus {
            outline: none;
            border-color: #667eea;
        }

        /* Modal */
        .modal {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.5);
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 1000;
        }

        .modal-content {
            background: white;
            padding: 30px;
            border-radius: 10px;
            width: 90%;
            max-width: 400px;
        }

        .modal-content h3 {
            margin-top: 0;
            margin-bottom: 20px;
        }

        .form-group {
            margin-bottom: 20px;
        }

        .form-group label {
            display: block;
            margin-bottom: 8px;
            font-weight: 600;
        }

        .form-group input {
            width: 100%;
            padding: 10px;
            border: 2px solid #e0e0e0;
            border-radius: 6px;
            font-size: 14px;
        }

        .form-group input:focus {
            outline: none;
            border-color: #667eea;
        }

        .modal-actions {
            display: flex;
            gap: 10px;
            justify-content: flex-end;
        }

        /* Notification */
        .notification {
            position: fixed;
            bottom: 20px;
            right: 20px;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            padding: 15px 25px;
            border-radius: 8px;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.2);
            animation: slideIn 0.3s ease;
            z-index: 1001;
        }

        @keyframes slideIn {
            from {
                transform: translateX(100%);
                opacity: 0;
            }
            to {
                transform: translateX(0);
                opacity: 1;
            }
        }

        /* OCR Controls */
        .ocr-controls {
            display: flex;
            align-items: center;
            gap: 12px;
            padding: 15px;
            background: linear-gradient(135deg, #e8f5e9 0%, #e3f2fd 100%);
            border-radius: 8px;
            border: 1px solid #c8e6c9;
            margin-bottom: 15px;
            flex-wrap: wrap;
        }

        .ocr-label {
            font-weight: 600;
            color: #333;
        }

        #ocr-status {
            font-size: 13px;
            color: #666;
        }

        #ocr-progress {
            font-weight: 600;
            color: #667eea;
        }

        #ocr-progress-display {
            font-size: 13px;
            color: #555;
            background: white;
            padding: 4px 10px;
            border-radius: 4px;
        }

        /* Scraping indicator */
        .scraping-indicator {
            font-size: 16px;
            font-weight: 500;
            animation: pulse 2s infinite;
        }

        .loading-more-row td {
            border-top: 2px dashed #667eea !important;
        }

        /* Checkbox column */
        .checkbox-col {
            width: 30px;
            text-align: center;
            padding: 4px !important;
        }

        .ad-checkbox, #select-all-ads {
            width: 16px;
            height: 16px;
            cursor: pointer;
            accent-color: #667eea;
        }

        /* OCR status badges */
        .ocr-cell {
            text-align: center;
            white-space: nowrap;
        }

        .ocr-status-badge {
            display: inline-block;
            padding: 3px 8px;
            border-radius: 10px;
            font-size: 11px;
            font-weight: 600;
        }

        .ocr-ok {
            background: #e8f5e9;
            color: #2e7d32;
        }

        .ocr-failed {
            background: #ffebee;
            color: #c62828;
        }

        .ocr-pending {
            background: #fff3e0;
            color: #e65100;
        }

        /* OCR failed count in controls bar */
        .ocr-failed-count {
            font-size: 13px;
            font-weight: 600;
            color: #c62828;
            background: #ffebee;
            padding: 4px 10px;
            border-radius: 4px;
        }
    </style>
</body>
</html>
